# 冒泡算法的原理：
冒泡算法就是将数组的元素两两交换位置，将大的数向后移，小的数向前移，最后会形成最大的数移到了数组的最后面

# 冒泡算法的思路：
依次比较相邻的两个数，将小的放在前面，大的放在后面。
  内层循环for(int j=0;j<nums.length-i-1;j++)
首先比较1，2两个数，交换；接着2，3两个数，交换……一直到数组的最后不用管已经排好的最大的数
  外层循环for(int i=0;i<nums.length-1;i++)
保存好已经排好的最大的数，控制内存循环遍历的长度

# 时间复杂度
最优的情况就是数组本来就是有序的，那么就不需要排序只要遍历完即可，那么这个时候的时间复杂度就是 T(n(n-1)/2)——> O(n^2)
最坏的情况就是每一次都需要交换，那么这个时候时间的复杂度就是  T(3n(n-1)/2)——>O(n^2) 多了三次的交换
那么综合来看冒泡排序的时间复杂度就是O(N^2)

# 空间复杂度
空间复杂度指的是在元素排序的过程中，所临时储存的空间
最优的情况就是数组本来是有序的，那么一次都不需要交换，就不需要临时的空间，那么空间复杂度就为 O(0)
最坏的情况就是数组逆序排列，那么每一次交换都需要一个临时的空间，那么空间复杂度就为O(n)
那么综合来说的话，空间的复杂度就为 O(1)
