# 快速排序的原理
将数组分成一半，前面一部分都要比后面一部分小，然后递归，直到整个数组都有序<br>
# 快速排序的思想
1. 判断数据的长度，做为递归结束的标志
2. 以第一个元素为目标元素，让它与后面的元素比较大小
3. 从数组的尾部开始，向前循环，得到一个比目标元素小的数A，然后把A放在第一个
4. 从头向后遍历，找到一个比目标元素大的数B，然后放在原先A的位置
5. 遍历结束后，最后一个元素放目标元素
6. 递归
# 时间复杂度分析
  ### 最优情况下的复杂度分析
  在最优的情况下，就是得到的数正好能平分整个数组，这时候复杂度的计算公式，加上递归的时间就为T(n)=2T(n/2)+f(n)<br>
  开始递归后，n=n/2，又被平分了一次，那么T(n)=2(2T(n/4)+f(n/2))+f(n)<br>
  再一次递归，n=n/(2^2),那么T(n)=2^2(2T(n/2^3)+f(n/2^3)+2f(n)<br>
  一直到最后，那么可以推算出来T(n)=nlogn+n<br>
  转换成高阶的无穷小就是O(nlogn)<br>
  ### 最坏情况下的复杂度分析
  最坏的情况其实就是冒泡排序了，一直取的是最大的，只能一个一个的放到后面去<br>
  那么这时的时间复杂度就为O(n^2)
  ### 平均时间复杂的
  O(nlogn)
# 空间复杂度分析
  对于递归之前的空间复杂度就是为O(1)<br>
  ### 最优情况下的空间复杂度
  最优情况下就是不断的把数组平分，那么这时的空间复杂度就是O(logn)
  ### 最坏情况下的空间复杂度
  最坏情况下就是把最大的数一直向后放每一次都要临时空间，那么这时的空间复杂度就是O(n)
