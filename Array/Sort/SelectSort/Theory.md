# 选择排序的原理
每一次循环都找出一个最小的数，放在数组的最前面，知道数组排序完成
# 选择排序的思想
for(int i = 0; i < nums.length; i++)<br>
外层循环，用来寻找最小值的下标，并且记录最小值的下标，然后用来交换位置<br>
for(int j = i + 1; j < nums.length; j++)<br>
内层循环，开始比较数值大小，找到最小值，然后记录最小值的下标<br>
最后交换位置
# 时间复杂度分析
选择排序的时间复杂度可以分为两部分，第一部分是不论最好还是最坏都会经历的第一次遍历<br>
T(n)=(n-1)+(n-2)+(n-3)+……+1=n(n-1)/2<br>
第二部分就是最优和最坏分开来，一个是完全不需要交换，一个是全部都需要交换<br>
最好的情况：T(0)<br>
最坏的情况：T(n)<br>
最后加起来就是：T(n)=n(n-1)/2+(0||n)——>O(n^2)<br>
所以最后的平均时间复杂度就为:O(n^2)
# 空间复杂度分析
最好的情况就是不需要交换，那么空间复杂度就为：O(0)<br>
最坏的情况就是每一次都需要交换，那么空间复杂度就为：O(n)<br>
最后平均的空间复杂度就是：O（1）<br>
